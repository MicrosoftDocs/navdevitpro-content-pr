---
title: "Handling Errors by Using Try Functions"
ms.custom: na
ms.date: 06/05/2016
ms.reviewer: na
ms.suite: na
ms.tgt_pltfrm: na
ms.topic: article
ms.prod: "dynamics-nav-2018"
ms.assetid: 5bb994f4-a0ac-4723-b35d-8211c356af29
caps.latest.revision: 11
manager: edupont
---
# Handling Errors by Using Try Functions
Try functions in C/AL enable you to handle errors that occur in the application during code execution. For example, with try functions, you can provide more user-friendly error messages to the end user than those thrown by the system.  

## Behavior and Usage  
The main purpose of try functions is to catch errors/exceptions that are thrown by [!INCLUDE[navnow](includes/navnow_md.md)] or exceptions that are thrown during .NET Framework interoperability operations. Try functions catch errors similar to a conditional Codeunit.Run function call, except try function calls do not require that write transactions are committed to the database, and changes to the database that are made with a try function are not rolled back.

### <a name="DbWriteTransactions"></a>Database write transactions in try functions
Because changes made to the database by a try function are not rolled back, you should not include database write transactions within a try function. By default, the [!INCLUDE[nav_server](includes/nav_server_md.md)] configuration prevents you from doing this. If a try function contains a database write transaction, a runtime error occurs.

>[!Note]
>This behavior is different from the behavior in [!INCLUDE[navcorfu_md](includes/navcorfu_md.md)], which did not include this restriction by default. Therefore, you might encounter errors if you have application code that was written for [!INCLUDE[navcorfu_md](includes/navcorfu_md.md)] and you run the code in [!INCLUDE[nav2017](includes/nav2017.md)].

>In practice, this means that you should not include the following function calls inside a try function scope:  

>|Data Type|Function|  
>|---------------|--------------|  
>|Record and RecordRef|-   INSERT<br />-   MODIFY<br />-   MODIFYALL<br />-   RENAME<br />-   DELETE<br />-   DELETEALL<br />-   >ADDLINK<br />-   DELETELINK<br />-   DELETELINKS|  
>|Database|-   COMMIT|

>If you want to change this behavior, you can set the **DisableWriteInsideTryFunctions** setting in the CustomSettings.config file of the server instance to **false**. However, we recommend that you design your code to suit the default behavior instead.

### Handling errors with a return value
A function that is designated as a try function has a Boolean return value \(true or false\), and has the construction `OK:= MyTryFunction`. A try function cannot have a user-defined return value.

- If a try function call does not use the return value, the try function operates like an ordinary function and errors are exposed as usual.  

- If a try function call uses the return value in an `OK:=` statement or a conditional statement such as `IF-THEN`, errors are caught.  

> [!NOTE]  
>  The return value is not accessible within the try function itself.  

### Getting details about errors
You can use the [GETLASTERRORTEXT Function](GETLASTERRORTEXT-Function.md) to obtain errors that are generated by [!INCLUDE[navnow](includes/navnow_md.md)]. To get details of exceptions that are generated by .NET Framework objects, you can use the [GETLASTERROROBJECT Function](GETLASTERROROBJECT-Function.md) to inspect the Expection.InnerException property.

> [!TIP]  
>  The [!INCLUDE[demolong](includes/demolong_md.md)] includes codeunit 1291 **DotNet Exception Handler** that includes several global functions for handling exceptions similar to a try-catch capability in C\#. You can use this codeunit together with try functions to handle exceptions and maximize the reuse of code.     

## Creating a Try Function  
To create a try function, add a function in C/AL code of an object \(such as a codeunit\) as usual, and then set the [TryFunction Property](TryFunction-Property.md) property to **Yes**. A try function has the following restrictions:  

In test and upgrade codeunits, you can only use a try function on a normal function type, as defined by the [FunctionType Property \(Test Codeunits\)](FunctionType-Property--Test-Codeunits-.md) or [FunctionType Property \(Upgrade Codeunits\)](FunctionType-Property--Upgrade-Codeunits-.md).  

### Example  
 The following example illustrates the use of a try function together with codeunit 1291 **DotNet Exception Handler** to handle .NET Framework Interoperability exceptions. The code is in text file format and has been simplified for illustration. The `CallTryPostingDotNet` function runs the try function `TryPostSomething` in a conditional statement to catch .NET Framework Interoperability exceptions. Errors other than `IndexOutOfRangeException` type are re-thrown.  

```  
[TryFunction]  
PROCEDURE TryPostingSomething@1();  
BEGIN  
  CODEUNIT.RUN(CODEUNIT::"Purch.-Post");  
END;  

PROCEDURE CallTryPostingDotNet @2();  
VAR  
  MyPostingCodeunit@1 : Codeunit 90;  
  MyDotNetExceptionHandler@2 : Codeunit 1291;  
  IndexOutOfRangeException@3 : DotNet 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IndexOutOfRangeException'  
BEGIN  
  IF TryPostingSomething THEN  
    MESSAGE('Posting succeeded.')  
  ELSE BEGIN  
    MyDotNetExceptionHandler.Collect;  
    IF MyDotNetExceptionHandler.TryCastToType(IndexOutOfRangeException) THEN  
      MESSAGE('The index used to find the value was not valid.')  
    ELSE  
      MyDotNetExceptionHandler.Rethrow;  
  END;  
END;  
```  

## See Also  
 [C/AL Function Statements](C-AL-Function-Statements.md)
